[ { "title": "Linux内核学习笔记-001-编译和启动内核", "url": "/posts/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%BC%96%E8%AF%91%E5%92%8C%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/", "categories": "Kernel", "tags": "inux, Kernel", "date": "2021-07-07 11:20:00 +0800", "snippet": "Linux内核学习笔记-001-编译和启动内核本文来源：Moeomu的博客准备环境 Ubuntu 20.04 LTS Linux 4.9.229 Busybox 1.33.0 qemu下载内核源代码和文件系统源代码 在站点Kernel.org下载linux-4.9.229.tar.gz 在站点Busybox.net下载busybox-1.33.0.tar.bz2 通过apt安装qemu：sudo apt install qemu-system-x86编译编译内核 export ARCH=x86 make x86_64_defconfig make menuconfig..." }, { "title": "ParallelsTools高版本Kali报错", "url": "/posts/ParallelsTools%E9%AB%98%E7%89%88%E6%9C%ACKali%E6%8A%A5%E9%94%99/", "categories": "Other", "tags": "Other, macOS", "date": "2021-07-06 15:55:00 +0800", "snippet": "macOS下的虚拟机Parallels的工具ParallelsTools安装于高版本Kali报错的解决办法本文来源：Moeomu的博客首先更新kali源 阿里云源如下deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib报错内容An error occurred while installing the following packages:- libelf-..." }, { "title": "Windows-GitGPG密钥配置", "url": "/posts/Windows-GitGPG%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/", "categories": "Other", "tags": "Other, Windows", "date": "2021-06-05 08:50:00 +0800", "snippet": "Windodws下的GitGPG密钥配置和开启签名验证本文来源：Moeomu的博客下载GPG4WIN下载链接：gpg4win创建和应用GPG密钥创建GPG密钥 创建：gpg --full-generate-key 密钥长度：4096 输入用户名、邮箱 列出所有密钥：gpg --list-secret-keys --keyid-format=long 根据keyid导出密钥：gpg --armor --export KEYID应用密钥 将密钥导入Github和Gitee配置Git Windows 配置默认用户名和邮箱，需要和创建GPG时设定的值保持一致 gi..." }, { "title": "Homebrew常用软件", "url": "/posts/Homebrew%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/", "categories": "Other", "tags": "Other, macOS", "date": "2021-06-01 09:31:00 +0800", "snippet": "Homebrew中的一些常用软件的记录会经常更新的本文来源：Moeomu的博客List Formulae 包名 用途 cmake auto-compile ffmpeg video processor gdb cpp debugger gpg gnupg htop processor monitor pandoc convert fi..." }, { "title": "macOS-GitGPG密钥配置", "url": "/posts/macOS-GitGPG%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/", "categories": "Other", "tags": "Other, macOS", "date": "2021-05-25 07:55:00 +0800", "snippet": "macOS下的GitGPG密钥配置和开启签名验证本文来源：Moeomu的博客关于GitHub GPG密钥验证开启Commit签名GitHub有个新的“警惕模式”，启用后GPG密钥需要签名认证的commit才会显示“Verity”，启用方法如下 首先创建GPG密钥（GitHub官方Docs有详细方法，不再赘述） 列出GPG密钥的特征码：gpg -K --keyid-format LONG，将keyid记录 告知git使用此GPG密钥：git config user.signingkey your_keyid 本地git的用户名和邮箱需要和GPG密钥生成时填入的相同：git conf..." }, { "title": "日常杂谈", "url": "/posts/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%B0%88/", "categories": "Other", "tags": "Other", "date": "2021-05-24 10:36:00 +0800", "snippet": "一些杂谈本文来源：Moeomu的博客Mention稍微提及一下，山西校企通的自动打卡项目经过思考之后将它决定将它开源，这只是一段赶工出来的不成熟的代码，因此可能会有些阅读困难，但是使用不会有问题，也已经稳定运行了半年多，Readme中我写了所有的使用方法和注意事项，以下是开源地址[Github]-XQT-Auto-Clockin 特性 全自动打卡 多用户自动打卡（为了防止服务器被封IP设置了延时打卡） 不需要账户密码，只需要身份证号即可 My Way似乎会经常陷入抑郁状态，似乎越来越难以控制自己，也许应该去医院看看了" }, { "title": "VSCode-Python-遇到的问题", "url": "/posts/VSCode-Python-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "Other", "tags": "Windows, Other", "date": "2021-01-19 17:48:00 +0800", "snippet": "记录一下在Windows写Python代码遇到的问题当然是很简单的一些小问题，算是本地备份一下笔记本文来源：Moeomu的博客VSCode-Python-Venv-PowerShell未签名环境无法激活 在Windows下激活VENV虚拟Python环境写代码遇到了PowerShell文件的无法运行的事情，原因是PowerShell脚本文件未签名，百度寻找了一下解决办法却是清一色的让将Windows安全策略改成签名，如下 set-executionpolicy remotesigned 总觉得不应该这样，这样修改策略实属下策，去谷歌找了一下解决办法，发现这是个2018年的问题，未有..." }, { "title": "Windows内核学习笔记-002", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-12-18 20:52:00 +0800", "snippet": "这一节依旧是基础内容的复习本文来源：Moeomu的博客字符串操作 内核中使用UNICODE_STRING结构来作为基本的字符串结构，应该注意的是使用此结构中的lenth成员确定字符串长度，而不是&#39;\\0&#39;。字符串初始化 函数：RtlInitUnicodeString 参数： PUNICODE_STRING: DestinationString PCWSTR: SourceString 返回值：无 IRQL：&amp;lt;=DISPATCH_LEVEL 解释：初始化一个以0结尾的WCHAR字符串，第一个参数是输入参数也是输..." }, { "title": "Windows内核学习笔记-001", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-12-18 18:52:00 +0800", "snippet": "这波啊，这波是又从头学起了，之前学的内核有些不系统，这次一定系统地整理一遍Windows内核编程的内容本文来源：Moeomu的博客Windows内核开发环境配置下载 开发机 Windows 10 20H2 x64 Visual Studio 2019 Windows Driver Kit - Windows 10.0.19041.685(Windows 10 2004) WinDbg Preview 测试机 Windows 10 2004 x64 DbgView测试驱动程序 还是使用最经典的HelloWorld来作为开始吧#include &amp;lt;ntddk.h..." }, { "title": "macOS-pd16修复网络", "url": "/posts/macOS-pd16%E4%BF%AE%E5%A4%8D%E7%BD%91%E7%BB%9C/", "categories": "Other", "tags": "macOS, Other", "date": "2020-12-16 13:42:00 +0800", "snippet": "macOS-parallels desktop网络初始化失败解决办法本文来源：Moeomu的博客前奏 在macOS Big Sur下可以使用 之前是使用命令启动的不完美解决办法，还会导致一系列权限问题，现在终于完美了解决方案 最高权限编辑文件/Library/Preferences/Parallels/network.desktop.xml 将UseKextless字段的值从-1改为0 注意：这个值可能并不是所有人-1，也可能并不是所有人改为0都行，勇于尝试嘛" }, { "title": "漏洞学习笔记-021-保护下的堆", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-021-%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-28 16:15:00 +0800", "snippet": "堆的保护和攻击本文来源：Moeomu的博客简介 PEB Random：微软在Windows XP SP2之后不再使用固定的PEB基址0x7ffdf000，而是使用具有一定随机性的PEB基址。PEB随机化之后主要影响了对PEB中函数的攻击，在DWORD SHOOT的时候，PEB中的函数指针是绝佳的目标，移动PEB基址将在一定程度上给这类攻击增加难度。覆盖PEB中函数指针的利用方式请参见堆溢出利用中的实验和攻击PEB中的函数指针的相关介绍 SafeUnlink：微软改写了操作双向链表的代码，在卸载free list中的堆块时更加小心。对照堆溢出利用-DWORD SHOOT中关于双向链表拆..." }, { "title": "漏洞学习笔记-020-SEHOP简介", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-020-SEHOP%E7%AE%80%E4%BB%8B/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-28 15:38:00 +0800", "snippet": "SEHOP的介绍和一点简单攻击本文来源：Moeomu的博客简介SEHOP的核心任务就是检查S.E.H链的完整性，在程序转入异常处理前SEHOP会检查S.E.H链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条S.E.H链没有被破坏，程序可以去执行当前的异常处理函数；如果检测到最后一个异常处理函数不是，则说明S.E.H链被破坏，可能发生了S.E.H覆盖攻击，程序将不会去执行当前的异常处理函数 SEHOP验证伪代码if (process_flags &amp;amp; 0x40 == 0) // 如果没有SEH记录则不进行检测{ if (record !=..." }, { "title": "漏洞学习笔记-019-利用HeapSpray攻击ASLR", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-019-%E5%88%A9%E7%94%A8HeapSpray%E6%94%BB%E5%87%BBASLR/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-28 12:38:00 +0800", "snippet": "利用Heap Spray(堆喷射)技术来攻击ASLR并定位shellcode本文来源：Moeomu的博客原理通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。只要运气不要差到0x0C0C0C0C刚好位于shellcode中的某个位置，shellcode就可以成功执行实验准备工作 环境：系统：Windows Vista SP0，DEP状态：默认，浏览器：IE7 还是将之前用过的Vulner_AX.dll作为攻击目标 VulnerAX.idl中CVulnerAXCtrl的类信息的UUID..." }, { "title": "漏洞学习笔记-018-利用部分覆盖定位", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-018-%E5%88%A9%E7%94%A8%E9%83%A8%E5%88%86%E8%A6%86%E7%9B%96%E5%AE%9A%E4%BD%8D/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-26 17:54:00 +0800", "snippet": "利用部分覆盖定位shellcode本文来源：Moeomu的博客原理 映像随机化指示对映像加载基址的全两个字节随机化处理，这样做的后果是跳板始终可用，因此可以利用这一点去绕过ASLR 如果攻击memcpy的话，可以将返回值控制在0xXXXX0000~0xXXXXFFFF之间，而攻击str类函数攻击，可以将控制地址为0xXXXX0100~0xXXXX00FF之间的一个过程 首先在编译完的程序内找到一条jmp eax的汇编码，随后将它的地址的低word作为off by word的地址，填入shellcode 计算好缓冲区大小，溢出后即可正常代码#include &amp;lt;memo..." }, { "title": "漏洞学习笔记-017-ASLR简介", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-017-ASLR%E7%AE%80%E4%BB%8B/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-24 21:12:00 +0800", "snippet": "ASLR技术的介绍和简单攻击思路本文来源：Moeomu的博客ASLR技术简介 纵观前面介绍的所有漏洞利用方法都有着一个共同的特征：都需要确定一个明确的跳转地址。无论是JMP ESP等通用跳板指令还是Ret2Libc使用的各指令，我们都要先确定这条指令的入口点。所谓惹不起躲得起，微软的ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制 实际上ASLR的概念在Windows XP时代就已经提出来了，只不过XP上面的ASLR功能很有限，只是对PEB和TEB进行了简单的..." }, { "title": "macOS-pkg文件解析", "url": "/posts/macOS-pkg%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/", "categories": "Other", "tags": "macOS, Other", "date": "2020-11-24 12:56:00 +0800", "snippet": "macOS-pkg文件解析&amp;amp;PD16无法联网解决办法&amp;amp;ls的@符号问题本文来源：Moeomu的博客起因ed2k链接没法用motrix下载，准备去下载一个迅雷的精简版，突然发现找出来的是pkg安装包，引起了我的兴趣经过解包 一直以来都很奇怪pkg究竟运行了哪些东西，又干了什么，因此开始第一步，解包 解包只需要一条命令即可：pkgutil --expand 需要解包的pkg.pkg 自定义解包文件夹名查看 发现有个Res文件，没有后缀，用file查看一下格式发现它被压缩了，索性unar指令解压，出来一个同名文件，但是大小变大了 在finder中右键-打..." }, { "title": "逆向工具-Radare2和Cutter", "url": "/posts/%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7-Radare2%E5%92%8CCutter/", "categories": "Reverse", "tags": "Reverse, Tools", "date": "2020-11-21 19:04:00 +0800", "snippet": "开源逆向神器-Radare2和Cutter本文来源：Moeomu的博客介绍Radare2 r2 is a rewrite from scratch of radare in order to provide a set of libraries and tools to work with binary files. Radare project started as a forensics tool, a scriptable command-line hexadecimal editor able to open disk files, but later a..." }, { "title": "漏洞学习笔记-016-利用可执行内存和.NET攻击DEP", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-016-%E5%88%A9%E7%94%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%92%8C.NET%E6%94%BB%E5%87%BBDEP/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-20 14:13:00 +0800", "snippet": "Ret2Libc之利用VirtualProtect和VirtualAlloc攻击DEP攻击DEP本文来源：Moeomu的博客利用可执行内存攻击DEP原理 有的时候在进程的内存空间中会存在一段可读可写可执行的内存，如果我们能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会代码#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char..." }, { "title": "漏洞学习笔记-015-利用VirtualProtect和VirtualAlloc攻击DEP", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-015-%E5%88%A9%E7%94%A8VirtualProtect%E5%92%8CVirtualAlloc%E6%94%BB%E5%87%BBDEP/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-19 17:43:00 +0800", "snippet": "Ret2Libc之利用VirtualProtect和VirtualAlloc攻击DEP攻击DEP本文来源：Moeomu的博客利用VirtualProtect攻击DEP原理 利用VirtualProtect函数将栈页内存属性改为可执行前置内容 VirtualProtect参数BOOL VirtualProtect( LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);// 所以可以这样写BOOL VirtualProtect( shellcode 所在内存空间..." }, { "title": "漏洞学习笔记-014-DEP的介绍", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-014-DEP%E7%9A%84%E4%BB%8B%E7%BB%8D/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-19 12:42:00 +0800", "snippet": "Windows的DEP保护和简单的攻击方法本文来源：Moeomu的博客DEP的介绍 溢出攻击的根源是未准确区分数据和代码，但是重新设计计算机结构是不太可能的事情，所以使用各种办法去减缓溢出攻击原理 将数据所在的内存页标为不可执行，而程序成功溢出进入shellcode时，CPU将会抛出执行异常 DEP分为软件DEP和硬件DEP，而软件DEP指的是SafeSEH，硬件DEP在AMD平台上称为No-Execute Page-Protection(NX)，Intel平台上称为Execute Disable Bit(XD) 操作系统通过设置内存页的NX和XD标记，来指明不能从此执行代码，P..." }, { "title": "漏洞学习笔记-013-SafeSEH简介和简单攻击", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-013-SafeSEH%E7%AE%80%E4%BB%8B%E5%92%8C%E7%AE%80%E5%8D%95%E6%94%BB%E5%87%BB/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-12 09:40:00 +0800", "snippet": "SafeSEH简介和简单攻击本文来源：Moeomu的博客SafeSEH简介工作 检查异常处理链是否位于当前程序的栈中。如果不在当前栈中，程序将终止异常处理函数的调用。 检查异常处理函数指针是否指向当前程序的栈中。如果指向当前栈中，程序将终止异常处理函数的调用。 在前面两项检查都通过后，程序调用一个全新的函数RtlIsValidHandler()，来对异常处理函数的有效性进行验证，此函数的工作如下 判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，校验函数将依次进行如下校验。 判断程序是否设置了IMAGE_..." }, { "title": "漏洞学习笔记-012-GS安全编译", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-012-GS%E5%AE%89%E5%85%A8%E7%BC%96%E8%AF%91/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-11 16:45:00 +0800", "snippet": "GS安全编译的原理和突破本文来源：Moeomu的博客GS安全编译的保护原理简介 在Vistual Studio 2003(VS 7.0)后，默认启用了这个编译选项 位置：Project -&amp;gt; project Properties -&amp;gt; Configuration Properties -&amp;gt; C/C++ -&amp;gt; Code Generaion -&amp;gt; Buffer Security Check GS在所有函数调用发生时，向栈帧内压入了一个额外的随机DWORD，这个随机数被称为canary，这个随机数就是Security ..." }, { "title": "Homebrew和Brewcask的安装", "url": "/posts/Homebrew%E5%92%8CBrewcask%E7%9A%84%E5%AE%89%E8%A3%85/", "categories": "Other", "tags": "macOS, Other", "date": "2020-11-10 19:43:00 +0800", "snippet": "HomeBrew的安装，真是历经了多次失败，在此总结一下成功之谈大家请注意时效性：本文写于2020/11/10&amp;amp;&amp;amp;本文更新于2021/07/02本文来源：Moeomu的博客安装git 方法一：安装XCode Terminal:xcode-select --install 方法二：直接去git网站下载git的macOS安装包安装HomeBrew 首先下载原版installer.sh的jsDelivr CDN镜像 输入下列指令运行： git config --global url.&quot;https://mirrors.ustc.ed..." }, { "title": "漏洞学习笔记-011-其它类型的漏洞和Windows安全机制", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-011-%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%92%8CWindows%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 18:50:00 +0800", "snippet": "其它类型的漏洞和Windows安全机制概述本文来源：Moeomu的博客格式化串漏洞printf中的缺陷 例子#include &quot;stdio.h&quot;void main(){ int a = 44,b = 77; printf(&quot;a=%d, b=%d\\n&quot;,a,b); printf(&quot;a=%d, b=%d\\n&quot;);} 上述代码中第二个调用缺少了输出数据的变量列表 然而第二次调用没有引起编译错误，程序正常执行用printf读取内存数据 例子#include &quot;stdio.h&quot;int main..." }, { "title": "漏洞学习笔记-010-HeapSpray", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-010-HeapSpray/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 17:56:00 +0800", "snippet": "Heap Spray - 堆与栈的协同攻击声明：实验环境为 Windows 2000本文来源：Moeomu的博客简介 针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞 当浏览器或其使用的ActiceX控件中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞 不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP 有时我们可能很难在浏览器中复杂的内存环境下不知完整的shellcode 页面中的JavaScript可以申请堆内存，因此shellcode通过JavaScript布置在堆中称为可能 shellcode放在堆中如何定位：HeapSpray技术细节 ..." }, { "title": "漏洞学习笔记-009-Windows异常的深入", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-009-Windows%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B7%B1%E5%85%A5/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 15:09:00 +0800", "snippet": "深入挖掘Windows异常处理，附带一些其它的利用方法声明：实验环境为 Windows XP SP3本文来源：Moeomu的博客不同级别的SEH 异常处理的最小作用域是线程，每个线程都拥有自己的SEH链表，发生错误时，首先使用自己的SEH进行处理 一个进程中可能同时存在很多个线程，进程中也由一个能处理全局的异常处理。当线程自身的SEH无法修复错误时，进程的SEH将处理异常。这种异常处理可能会影响到进程下属的所有线程 操作系统为所有程序提供了一个默认的异常处理函数，当所有的异常处理函数都无法处理错误时，这个默认的异常处理函数将被最终调用，结果一般时显示要给错误对话框 以下是简单的异..." }, { "title": "漏洞学习笔记-008-Windows异常的利用", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-008-Windows%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%A9%E7%94%A8/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 11:32:00 +0800", "snippet": "SEH的栈利用和堆利用声明：实验环境为 Windows 2000本文来源：Moeomu的博客SEH概述 SEH是异常处理结构体(Structure Exception Handler)，是Windows异常处理机制采用的重要的数据结构。每个SEH包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共8个字节 SEH结构存放在栈中 线程初始化时，自动向栈中安装一个SEH作为线程默认的异常处理 如果程序源代码中使用了try-except等异常处理机制，编译器最终通过向当前函数栈帧中安装一个SEH来实现异常处理 栈中一般会同时存在多个SEH 栈中的多个SEH通过链表指针在栈内..." }, { "title": "漏洞学习笔记-007-堆溢出的利用", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-007-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A9%E7%94%A8/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-22 16:56:00 +0800", "snippet": "堆溢出的利用声明：实验环境为 Windows 2000本文来源：Moeomu的博客链表的拆卸理论 堆块分配：将堆块从空表中“卸下” 堆块释放：把堆块链入空表 堆块合并：把若干个堆块从空表中“卸下”，修改块首信息(大小)，之后把更新后的新块“链入”空表 利用堆溢出：构造数据溢出下一个堆块的块首，改写块首中的前向指针和后向指针，然后在分配释放合并等操作发生时伺机获得依次向内存任意地址写入任意数据的机会 这种向任意位置写入任意数据的机会称为DWORD SHOOT/ARBITARY DWORD RESET 目标 载荷 改写后的结果 ..." }, { "title": "漏洞学习笔记-006-堆的入门", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-006-%E5%A0%86%E7%9A%84%E5%85%A5%E9%97%A8/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-20 23:10:00 +0800", "snippet": "Windows的堆，从来都是一个乱糟糟的地方，管理方法也非常奇怪声明：实验环境为 Windows 2000本文来源：Moeomu的博客堆的介绍与栈的区别 堆是由程序员使用malloc等函数向操作系统申请的一块内存空间，它能否成功与操作系统的状态有极大的关系，与管理整齐的栈不同，它的管理以及分配算法都是非常奇特的 堆在释放时由程序员使用free或delete释放，而栈是系统自动释放的 堆的地址范围变化很大，而栈的内存地址总是0x0012XXXX 堆的地址由低向高移动，栈的地址由高向低移动堆的安全 堆是杂乱无章的，所以它的利用相对于栈会困难很多，而堆的管理微软从未公开，研究有一定困..." }, { "title": "漏洞学习笔记-005-Metasploit制作ShellCode", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-005-Metasploit%E5%88%B6%E4%BD%9CShellCode/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-20 22:20:00 +0800", "snippet": "Metasploit制作ShellCode本文来源：Moeomu的博客…未完待续(Metasploit旧版本真难找)…入侵Windows实验实验介绍 MS06-040，CVE-2006-3439   推荐的环境 备注 攻击机系统 Kali Linux 2021.1   目标主机系统 Windows 2000 SP4   补丁版本 KB921883 确保目标主机未安装补丁 网络..." }, { "title": "漏洞学习笔记-004-ShellCode编码", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-004-ShellCode%E7%BC%96%E7%A0%81/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-20 09:20:00 +0800", "snippet": "ShellCode编码和减少体积 点击此处下载本文附可执行程序，shellcode文件本文来源：Moeomu的博客异或编码注意事项 在选取编码字节时，不可与已有字节相同，否则会出现0 可以使用多个不同编码字节对不同区域编码，但会增加复杂度 可以对shellcode进行多轮编码实现代码(ExpStd0401)void encoder(char* input, unsigned char key, int display_flag){ int i = 0, len = 0; FILE* fp; unsigned char * output; len = str..." }, { "title": "漏洞学习笔记-003-API动态加载", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-003-API%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-19 20:20:00 +0800", "snippet": "ShellCode的API动态定位 点击此处下载本文附可执行程序，shellcode文件本文来源：Moeomu的博客通过TEB定位API地址定位Kernel32.dll 程序加载时，用户态下[FS:0]寄存器中存放TEB地址 TEB偏移0x30的位置[TEB + 0x30]存放PEB的地址 PEB偏移0xC的位置[PEB + 0xC]存放PEB_LDR_DATA 关于PEB_LDR_DATA结构，微软官方的说明点此，C语言表示如下typedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserv..." }, { "title": "漏洞学习笔记-002-ESP跳板", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-ESP%E8%B7%B3%E6%9D%BF/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-19 18:20:00 +0800", "snippet": "ShellCode的动态定位法-ESP跳板法 点击此处下载本文附可执行程序，shellcode文件本文来源：Moeomu的博客栈空间移位ShellCode在内存中往往是动态的，并非直接填写一个定值也就是前一篇中buffer数组的栈空间地址，并非总是个定值当CPU执行到此地址时，有可能触发无效指令异常导致程序崩溃，ShellCode无法运行原理从程序已加载的系统DLL中查找一个JMP ESP指令的地址，用此地址去淹没返回地址这样既能精准定位shellcode的位置，又能适应栈空间的动态变化栈的地址是上小下大，CPU的执行顺序是小地址到大地址，栈淹没同样从小地址淹没到大地址这样只要将前面的..." }, { "title": "漏洞学习笔记-001-缓冲区溢出", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-18 10:00:00 +0800", "snippet": " 能够引起软件做一些超出涉及范围的事情的bug叫做漏洞，本篇写了一些简单的缓冲区溢出漏洞的利用浅析 功能性逻辑缺陷(Bug) 安全性逻辑缺陷(Vulnerability) 点击此处下载本文附代码，可执行程序，shellcode文件本文来源：Moeomu的博客PE概念PE文件与虚拟内存之间的映射 ImageBase：装载基址，对(.EXE)是0x00400000，对(.DLL)是0x10000000 FileOffset：文件偏移地址 VirtualAddress：虚拟地址，是映射到内存中的地址 RelativeVirtualAddress：相对虚拟地址，是..." }, { "title": "Windows内核调试学习笔记-002-结构体", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-%E7%BB%93%E6%9E%84%E4%BD%93/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-10-17 20:23:00 +0800", "snippet": "Windows内核的相关的一些学习笔记，这一篇主要是描述EPROCESS，PEB的结构本文来源：Moeomu的博客非公开内核结构Windows的非公开结构非常多，而有些结构是半公开的，虽然有字段名，但只能推测其用意WinDbg能加载一些内核调试符号，在这些PDB文件中，有一些半公开结构的信息EPROCESS(KPEB)(Kernel Process Environment Block)每一个进程都由一个EPROCESS结构表示，而这些结构被一个双向链表所连接结构信息 0x000偏移是PCB(Process Control Block)的地址，它位于R0中 0x0b4偏移是PID，它是..." }, { "title": "Windows内核调试学习笔记-001-环境搭建", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-10-17 19:27:00 +0800", "snippet": "Windows内核的相关的一些学习笔记，这一篇主要是环境的搭建本文来源：Moeomu的博客下载工具 Windows 7 SP1 x86 镜像迅雷下载链接 VMWare Workstation 16(链接在下方) WinDbg Preview(Microsoft Store)安装Windows虚拟机 最初以Windows 7 SP1 x86为例子来学习 MSDN下载官方镜像 VMWare Workstation 16搭建虚拟环境 下载：VMWare 16 Link 密钥：ZF3R0-FHED2-M80TY-8QYGC-NPKYF 配置Win..." } ]
